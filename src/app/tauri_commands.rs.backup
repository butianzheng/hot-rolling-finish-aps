// ==========================================
// 热轧精整排产系统 - Tauri 命令
// ==========================================
// 职责: Tauri 命令定义,连接前端与后端 API
// 依据: 实施计划 Phase 5
// ==========================================

#![cfg(feature = "tauri-app")]

use serde::{Deserialize, Serialize};
use chrono::NaiveDate;
use tauri::Manager;
use uuid::Uuid;

use crate::app::state::AppState;
use crate::api::error::ApiError;
use crate::domain::action_log::ActionLog;
use crate::engine::ScheduleStrategy;

// ==========================================
// 错误响应类型
// ==========================================

/// 错误响应（返回给前端）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorResponse {
    /// 错误代码
    pub code: String,

    /// 错误消息
    pub message: String,

    /// 详细信息（可选）
    pub details: Option<serde_json::Value>,
}

/// 将ApiError转换为JSON字符串（Tauri要求）
fn map_api_error(err: ApiError) -> String {
    let error_response = ErrorResponse {
        code: match &err {
            ApiError::FrozenZoneProtection(_) => "FROZEN_ZONE_PROTECTION",
            ApiError::MaturityConstraintViolation { .. } => "MATURITY_CONSTRAINT_VIOLATION",
            ApiError::CapacityConstraintViolation { .. } => "CAPACITY_CONSTRAINT_VIOLATION",
            ApiError::RedLineViolation(_) => "RED_LINE_VIOLATION",
            ApiError::InvalidInput(_) => "INVALID_INPUT",
            ApiError::NotFound(_) => "NOT_FOUND",
            ApiError::BusinessRuleViolation(_) => "BUSINESS_RULE_VIOLATION",
            ApiError::InvalidStateTransition { .. } => "INVALID_STATE_TRANSITION",
            ApiError::OptimisticLockFailure(_) => "OPTIMISTIC_LOCK_FAILURE",
            ApiError::VersionConflict(_) => "VERSION_CONFLICT",
            ApiError::DatabaseError(_) => "DATABASE_ERROR",
            ApiError::DatabaseConnectionError(_) => "DATABASE_CONNECTION_ERROR",
            ApiError::DatabaseTransactionError(_) => "DATABASE_TRANSACTION_ERROR",
            ApiError::ImportError(_) => "IMPORT_ERROR",
            ApiError::ValidationError(_) => "VALIDATION_ERROR",
            ApiError::ManualOperationValidationError { .. } => "MANUAL_OPERATION_VALIDATION_ERROR",
            ApiError::InternalError(_) => "INTERNAL_ERROR",
            ApiError::Other(_) => "OTHER_ERROR",
        }
        .to_string(),
        message: err.to_string(),
        details: match &err {
            ApiError::ManualOperationValidationError { violations, .. } => {
                Some(serde_json::json!({ "violations": violations }))
            }
            _ => None,
        },
    };

    serde_json::to_string(&error_response).unwrap_or_else(|_| err.to_string())
}

/// 解析日期字符串
fn parse_date(date_str: &str) -> Result<NaiveDate, String> {
    NaiveDate::parse_from_str(date_str, "%Y-%m-%d")
        .map_err(|e| format!("日期格式错误（应为YYYY-MM-DD）: {}", e))
}

/// best-effort: emit a frontend event; do not fail the command if emitting fails.
fn emit_frontend_event(app: &tauri::AppHandle, event: &str, payload: serde_json::Value) {
    if let Err(e) = app.emit_all(event, payload) {
        tracing::warn!("emit_all failed: event={}, error={}", event, e);
    }
}

// ==========================================
// 前端遥测/错误上报
// ==========================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportFrontendEventResponse {
    pub success: bool,
    pub message: String,
}

/// 前端日志/错误上报：写入 action_log（便于复用现有查询界面）
///
/// 约定：
/// - action_type: FRONTEND_ERROR / FRONTEND_WARN / FRONTEND_INFO / FRONTEND_DEBUG / FRONTEND_EVENT
/// - payload_json: 由前端组织，后端仅做落库
#[tauri::command(rename_all = "snake_case")]
pub async fn report_frontend_event(
    state: tauri::State<'_, AppState>,
    version_id: Option<String>,
    actor: Option<String>,
    level: String,
    message: String,
    payload_json: serde_json::Value,
) -> Result<String, String> {
    // 尽量关联到一个“可追溯”的版本：
    // - 优先使用前端传入的 version_id（通常是当前激活版本）
    // - 否则尝试回填“最近激活版本”
    let mut resolved_version_id = version_id
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty());

    if resolved_version_id.is_none() {
        resolved_version_id = state
            .plan_api
            .get_latest_active_version_id()
            .map_err(map_api_error)?
            .filter(|s| !s.trim().is_empty());
    }

    // 若仍无法关联版本，则跳过写入（best-effort，不影响前端流程）
    let Some(version_id) = resolved_version_id else {
        let resp = ReportFrontendEventResponse {
            success: true,
            message: "未找到可关联的激活版本，已跳过写入".to_string(),
        };
        return serde_json::to_string(&resp).map_err(|e| format!("序列化失败: {}", e));
    };

    let actor = actor
        .unwrap_or_else(|| "unknown".to_string())
        .trim()
        .to_string();

    let level_norm = level.trim().to_lowercase();
    let action_type = match level_norm.as_str() {
        "error" => "FRONTEND_ERROR",
        "warn" | "warning" => "FRONTEND_WARN",
        "info" => "FRONTEND_INFO",
        "debug" => "FRONTEND_DEBUG",
        _ => "FRONTEND_EVENT",
    };

    let log = ActionLog {
        action_id: Uuid::new_v4().to_string(),
        version_id,
        action_type: action_type.to_string(),
        action_ts: chrono::Local::now().naive_local(),
        actor,
        payload_json: Some(serde_json::json!({
            "level": level_norm,
            "message": message,
            "payload": payload_json,
        })),
        impact_summary_json: None,
        machine_code: None,
        date_range_start: None,
        date_range_end: None,
        detail: Some(message),
    };

    // best-effort: 上报失败不应影响前端流程
    if let Err(e) = state.action_log_repo.insert(&log) {
        tracing::warn!("report_frontend_event insert failed: {}", e);
    }

    let resp = ReportFrontendEventResponse {
        success: true,
        message: "OK".to_string(),
    };
    serde_json::to_string(&resp).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 材料相关命令
// ==========================================

/// 查询材料列表
#[tauri::command(rename_all = "snake_case")]
pub async fn list_materials(
    state: tauri::State<'_, AppState>,
    machine_code: Option<String>,
    steel_grade: Option<String>,
    limit: i32,
    offset: i32,
) -> Result<String, String> {
    let result = state
        .material_api
        .list_materials(machine_code, steel_grade, limit, offset)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询材料详情
#[tauri::command(rename_all = "snake_case")]
pub async fn get_material_detail(
    state: tauri::State<'_, AppState>,
    material_id: String,
) -> Result<String, String> {
    let result = state
        .material_api
        .get_material_detail(&material_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询适温待排材料
#[tauri::command(rename_all = "snake_case")]
pub async fn list_ready_materials(
    state: tauri::State<'_, AppState>,
    machine_code: Option<String>,
) -> Result<String, String> {
    let result = state
        .material_api
        .list_ready_materials(machine_code)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 批量锁定/解锁材料
#[tauri::command(rename_all = "snake_case")]
pub async fn batch_lock_materials(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    material_ids: Vec<String>,
    lock_flag: bool,
    operator: String,
    reason: String,
    mode: Option<String>,
) -> Result<String, String> {
    use crate::api::ValidationMode;

    let material_count = material_ids.len();

    // 解析校验模式，默认为Strict
    let validation_mode = match mode.as_deref() {
        Some("AutoFix") => ValidationMode::AutoFix,
        _ => ValidationMode::Strict,
    };

    let result = state
        .material_api
        .batch_lock_materials(material_ids, lock_flag, &operator, &reason, validation_mode)
        .map_err(map_api_error)?;

    emit_frontend_event(
        &app,
        "material_state_changed",
        serde_json::json!({ "count": material_count, "lock_flag": lock_flag }),
    );

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 批量强制放行材料
#[tauri::command(rename_all = "snake_case")]
pub async fn batch_force_release(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    material_ids: Vec<String>,
    operator: String,
    reason: String,
    mode: Option<String>,
) -> Result<String, String> {
    use crate::api::ValidationMode;

    let material_count = material_ids.len();

    // 解析校验模式，默认为Strict
    let validation_mode = match mode.as_deref() {
        Some("AutoFix") => ValidationMode::AutoFix,
        _ => ValidationMode::Strict,
    };

    let result = state
        .material_api
        .batch_force_release(material_ids, &operator, &reason, validation_mode)
        .map_err(map_api_error)?;

    emit_frontend_event(&app, "material_state_changed", serde_json::json!({ "count": material_count }));

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 批量设置紧急标志
#[tauri::command(rename_all = "snake_case")]
pub async fn batch_set_urgent(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    material_ids: Vec<String>,
    manual_urgent_flag: bool,
    operator: String,
    reason: String,
) -> Result<String, String> {
    let material_count = material_ids.len();

    let result = state
        .material_api
        .batch_set_urgent(material_ids, manual_urgent_flag, &operator, &reason)
        .map_err(map_api_error)?;

    emit_frontend_event(
        &app,
        "material_state_changed",
        serde_json::json!({ "count": material_count, "manual_urgent_flag": manual_urgent_flag }),
    );

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 按紧急等级查询材料
#[tauri::command(rename_all = "snake_case")]
pub async fn list_materials_by_urgent_level(
    state: tauri::State<'_, AppState>,
    urgent_level: String,
    machine_code: Option<String>,
) -> Result<String, String> {
    use crate::domain::types::UrgentLevel;

    let level = match urgent_level.as_str() {
        "L0" => UrgentLevel::L0,
        "L1" => UrgentLevel::L1,
        "L2" => UrgentLevel::L2,
        "L3" => UrgentLevel::L3,
        _ => return Err(format!("无效的紧急等级: {}", urgent_level)),
    };

    let result = state
        .material_api
        .list_materials_by_urgent_level(level, machine_code)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 排产方案相关命令
// ==========================================

/// 创建排产方案
#[tauri::command(rename_all = "snake_case")]
pub async fn create_plan(
    state: tauri::State<'_, AppState>,
    plan_name: String,
    created_by: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .create_plan(plan_name, created_by)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询方案列表
#[tauri::command(rename_all = "snake_case")]
pub async fn list_plans(state: tauri::State<'_, AppState>) -> Result<String, String> {
    let result = state.plan_api.list_plans().map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询方案详情
#[tauri::command(rename_all = "snake_case")]
pub async fn get_plan_detail(
    state: tauri::State<'_, AppState>,
    plan_id: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .get_plan_detail(&plan_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询最近创建的激活版本ID（跨方案）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_latest_active_version_id(
    state: tauri::State<'_, AppState>,
) -> Result<String, String> {
    let result = state
        .plan_api
        .get_latest_active_version_id()
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 删除排产方案（级联删除版本与明细）
#[tauri::command(rename_all = "snake_case")]
pub async fn delete_plan(
    state: tauri::State<'_, AppState>,
    plan_id: String,
    operator: String,
) -> Result<String, String> {
    state
        .plan_api
        .delete_plan(&plan_id, &operator)
        .map_err(map_api_error)?;

    Ok("{}".to_string())
}

/// 删除版本（仅允许删除非激活版本）
#[tauri::command(rename_all = "snake_case")]
pub async fn delete_version(
    state: tauri::State<'_, AppState>,
    version_id: String,
    operator: String,
) -> Result<String, String> {
    state
        .plan_api
        .delete_version(&version_id, &operator)
        .map_err(map_api_error)?;

    Ok("{}".to_string())
}

/// 创建新版本
#[tauri::command(rename_all = "snake_case")]
pub async fn create_version(
    state: tauri::State<'_, AppState>,
    plan_id: String,
    window_days: i32,
    frozen_from_date: Option<String>,
    note: Option<String>,
    created_by: String,
) -> Result<String, String> {
    let frozen_date = frozen_from_date
        .map(|s| parse_date(&s))
        .transpose()?;

    let result = state
        .plan_api
        .create_version(plan_id, window_days, frozen_date, note, created_by)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询版本列表
#[tauri::command(rename_all = "snake_case")]
pub async fn list_versions(
    state: tauri::State<'_, AppState>,
    plan_id: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .list_versions(&plan_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 激活版本
#[tauri::command(rename_all = "snake_case")]
pub async fn activate_version(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    version_id: String,
    operator: String,
) -> Result<String, String> {
    state
        .plan_api
        .activate_version(&version_id, &operator)
        .map_err(map_api_error)?;

    // 版本切换后，多个页面需要联动刷新（plan items / decision read models / KPI）。
    emit_frontend_event(&app, "plan_updated", serde_json::json!({ "version_id": version_id }));
    emit_frontend_event(&app, "risk_snapshot_updated", serde_json::json!({}));

    Ok("{}".to_string()) // 返回空JSON对象表示成功
}

/// 版本回滚（激活历史版本 + 恢复配置快照）
#[tauri::command(rename_all = "snake_case")]
pub async fn rollback_version(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    plan_id: String,
    target_version_id: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .rollback_version(&plan_id, &target_version_id, &operator, &reason)
        .map_err(map_api_error)?;

    // 回滚后，多个页面需要联动刷新（plan items / decision read models / KPI）。
    emit_frontend_event(
        &app,
        "plan_updated",
        serde_json::json!({ "version_id": target_version_id }),
    );
    emit_frontend_event(&app, "risk_snapshot_updated", serde_json::json!({}));

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 试算接口（沙盘模式）
#[tauri::command(rename_all = "snake_case")]
pub async fn simulate_recalc(
    state: tauri::State<'_, AppState>,
    version_id: String,
    base_date: String,
    frozen_date: Option<String>,
    operator: String,
    strategy: Option<String>,
) -> Result<String, String> {
    let base_date = parse_date(&base_date)?;
    let frozen_date = frozen_date.map(|s| parse_date(&s)).transpose()?;

    let strategy = strategy
        .as_deref()
        .unwrap_or("balanced")
        .parse::<ScheduleStrategy>()
        .map_err(|e| format!("策略类型解析失败: {}", e))?;

    let result = state
        .plan_api
        .simulate_recalc_with_strategy(&version_id, base_date, frozen_date, &operator, strategy)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 一键重算
#[tauri::command(rename_all = "snake_case")]
pub async fn recalc_full(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    version_id: String,
    base_date: String,
    frozen_date: Option<String>,
    operator: String,
    strategy: Option<String>,
) -> Result<String, String> {
    let base_date = parse_date(&base_date)?;
    let frozen_date = frozen_date.map(|s| parse_date(&s)).transpose()?;

    let strategy = strategy
        .as_deref()
        .unwrap_or("balanced")
        .parse::<ScheduleStrategy>()
        .map_err(|e| format!("策略类型解析失败: {}", e))?;

    let result = state
        .plan_api
        .recalc_full_with_strategy(&version_id, base_date, frozen_date, &operator, strategy)
        .map_err(map_api_error)?;

    let version_id_for_event = result.version_id.clone();
    emit_frontend_event(
        &app,
        "plan_updated",
        serde_json::json!({ "version_id": version_id_for_event }),
    );
    emit_frontend_event(&app, "risk_snapshot_updated", serde_json::json!({}));

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 获取预设策略列表（用于策略草案对比）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_strategy_presets(
    state: tauri::State<'_, AppState>,
) -> Result<String, String> {
    let result = state
        .plan_api
        .get_strategy_presets()
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 生成多策略草案（dry-run，不落库）
#[tauri::command(rename_all = "snake_case")]
pub async fn generate_strategy_drafts(
    state: tauri::State<'_, AppState>,
    base_version_id: String,
    plan_date_from: String,
    plan_date_to: String,
    strategies: Vec<String>,
    operator: String,
) -> Result<String, String> {
    let from = parse_date(&plan_date_from)?;
    let to = parse_date(&plan_date_to)?;

    let result = state
        .plan_api
        .generate_strategy_drafts(&base_version_id, from, to, strategies, &operator)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 发布策略草案：生成正式版本（落库）
#[tauri::command(rename_all = "snake_case")]
pub async fn apply_strategy_draft(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    draft_id: String,
    operator: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .apply_strategy_draft(&draft_id, &operator)
        .map_err(map_api_error)?;

    let version_id_for_event = result.version_id.clone();
    emit_frontend_event(
        &app,
        "plan_updated",
        serde_json::json!({ "version_id": version_id_for_event }),
    );
    emit_frontend_event(&app, "risk_snapshot_updated", serde_json::json!({}));

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询策略草案变更明细（用于前端抽屉展示）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_strategy_draft_detail(
    state: tauri::State<'_, AppState>,
    draft_id: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .get_strategy_draft_detail(&draft_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 列出策略草案（用于页面刷新/重启后的恢复）
#[tauri::command(rename_all = "snake_case")]
pub async fn list_strategy_drafts(
    state: tauri::State<'_, AppState>,
    base_version_id: String,
    plan_date_from: String,
    plan_date_to: String,
    status_filter: Option<String>,
    limit: Option<i64>,
) -> Result<String, String> {
    let from = parse_date(&plan_date_from)?;
    let to = parse_date(&plan_date_to)?;

    let result = state
        .plan_api
        .list_strategy_drafts(&base_version_id, from, to, status_filter, limit)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 清理过期草案（避免草案表无限增长）
#[tauri::command(rename_all = "snake_case")]
pub async fn cleanup_expired_strategy_drafts(
    state: tauri::State<'_, AppState>,
    keep_days: i64,
) -> Result<String, String> {
    let result = state
        .plan_api
        .cleanup_expired_strategy_drafts(keep_days)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询排产明细
#[tauri::command(rename_all = "snake_case")]
pub async fn list_plan_items(
    state: tauri::State<'_, AppState>,
    version_id: String,
    plan_date_from: Option<String>,
    plan_date_to: Option<String>,
    machine_code: Option<String>,
    limit: Option<i64>,
    offset: Option<i64>,
) -> Result<String, String> {
    let from = plan_date_from
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(parse_date)
        .transpose()?;

    let to = plan_date_to
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(parse_date)
        .transpose()?;

    let machine_code = machine_code
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(|s| s.to_string());

    let has_filters = from.is_some()
        || to.is_some()
        || machine_code.is_some()
        || limit.is_some()
        || offset.is_some();

    let result = if has_filters {
        state
            .plan_api
            .list_plan_items_filtered(
                &version_id,
                machine_code.as_deref(),
                from,
                to,
                limit,
                offset,
            )
            .map_err(map_api_error)?
    } else {
        state
            .plan_api
            .list_plan_items(&version_id)
            .map_err(map_api_error)?
    };

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 按日期查询排产明细
#[tauri::command(rename_all = "snake_case")]
pub async fn list_items_by_date(
    state: tauri::State<'_, AppState>,
    version_id: String,
    plan_date: String,
) -> Result<String, String> {
    let date = parse_date(&plan_date)?;

    let result = state
        .plan_api
        .list_items_by_date(&version_id, date)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 版本对比
#[tauri::command(rename_all = "snake_case")]
pub async fn compare_versions(
    state: tauri::State<'_, AppState>,
    version_id_a: String,
    version_id_b: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .compare_versions(&version_id_a, &version_id_b)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 版本对比 KPI 汇总（聚合）
#[tauri::command(rename_all = "snake_case")]
pub async fn compare_versions_kpi(
    state: tauri::State<'_, AppState>,
    version_id_a: String,
    version_id_b: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .compare_versions_kpi(&version_id_a, &version_id_b)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 移动排产项
///
/// # 参数
/// - version_id: 版本ID
/// - moves: 移动项列表 (JSON字符串)
/// - mode: 校验模式 (AUTO_FIX/STRICT)
/// - operator: 操作人（写入操作日志）
/// - reason: 操作原因（可选）
#[tauri::command(rename_all = "snake_case")]
pub async fn move_items(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    version_id: String,
    moves: String,
    mode: Option<String>,
    operator: String,
    reason: Option<String>,
) -> Result<String, String> {
    use crate::api::ValidationMode;
    use crate::api::plan_api::MoveItemRequest;

    // 解析移动项列表
    let move_requests: Vec<MoveItemRequest> = serde_json::from_str(&moves)
        .map_err(|e| format!("解析移动项失败: {}", e))?;

    // 解析校验模式，默认为Strict（兼容 AutoFix 和 AUTO_FIX 两种格式）
    let validation_mode = match mode.as_deref() {
        Some("AutoFix") | Some("AUTO_FIX") => ValidationMode::AutoFix,
        _ => ValidationMode::Strict,
    };

    let result = state
        .plan_api
        .move_items(&version_id, move_requests, validation_mode, &operator, reason.as_deref())
        .map_err(map_api_error)?;

    emit_frontend_event(
        &app,
        "plan_updated",
        serde_json::json!({ "version_id": version_id, "has_violations": result.has_violations }),
    );
    emit_frontend_event(&app, "risk_snapshot_updated", serde_json::json!({}));

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 驾驶舱相关命令
// ==========================================

/// 查询风险快照列表
#[tauri::command(rename_all = "snake_case")]
pub async fn list_risk_snapshots(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .list_risk_snapshots(&version_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询风险快照（按日期）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_risk_snapshot(
    state: tauri::State<'_, AppState>,
    version_id: String,
    snapshot_date: String,
) -> Result<String, String> {
    let date = parse_date(&snapshot_date)?;

    let result = state
        .dashboard_api
        .get_risk_snapshot(&version_id, date)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 哪天最危险
#[tauri::command(rename_all = "snake_case")]
pub async fn get_most_risky_date(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .get_most_risky_date(&version_id, None, None, None, None)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 哪些紧急单无法完成
#[tauri::command(rename_all = "snake_case")]
pub async fn get_unsatisfied_urgent_materials(
    state: tauri::State<'_, AppState>,
    version_id: Option<String>,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .get_unsatisfied_urgent_materials(version_id.as_deref())
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 哪些冷料压库（向后兼容版本，使用 version_id）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_cold_stock_materials(
    state: tauri::State<'_, AppState>,
    version_id: String,
    threshold_days: Option<i32>,
) -> Result<String, String> {
    // threshold_days 参数为向后兼容保留，不再使用
    let _ = threshold_days;

    let result = state
        .dashboard_api
        .get_cold_stock_materials_full(&version_id, None, None, Some(100))
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 哪个机组最堵（向后兼容版本，使用 version_id）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_most_congested_machine(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .get_most_congested_machine_full(&version_id, None, None, None, None, Some(10))
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 获取决策数据刷新状态（P0-2）
#[tauri::command(rename_all = "snake_case")]
pub async fn get_refresh_status(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .get_refresh_status(&version_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 手动触发决策读模型刷新（P0-2：失败可重试）
#[tauri::command(rename_all = "snake_case")]
pub async fn manual_refresh_decision(
    state: tauri::State<'_, AppState>,
    version_id: String,
    operator: String,
) -> Result<String, String> {
    let result = state
        .plan_api
        .manual_refresh_decision(&version_id, &operator)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询操作日志（按时间范围）
#[tauri::command(rename_all = "snake_case")]
pub async fn list_action_logs(
    state: tauri::State<'_, AppState>,
    start_time: String,
    end_time: String,
) -> Result<String, String> {
    use chrono::NaiveDateTime;

    let start = NaiveDateTime::parse_from_str(&start_time, "%Y-%m-%d %H:%M:%S")
        .map_err(|e| format!("开始时间格式错误: {}", e))?;

    let end = NaiveDateTime::parse_from_str(&end_time, "%Y-%m-%d %H:%M:%S")
        .map_err(|e| format!("结束时间格式错误: {}", e))?;

    let result = state
        .dashboard_api
        .list_action_logs(start, end)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询操作日志（按材料ID + 时间范围）
#[tauri::command(rename_all = "snake_case")]
pub async fn list_action_logs_by_material(
    state: tauri::State<'_, AppState>,
    material_id: String,
    start_time: String,
    end_time: String,
    limit: Option<i32>,
) -> Result<String, String> {
    use chrono::NaiveDateTime;

    let start = NaiveDateTime::parse_from_str(&start_time, "%Y-%m-%d %H:%M:%S")
        .map_err(|e| format!("开始时间格式错误: {}", e))?;

    let end = NaiveDateTime::parse_from_str(&end_time, "%Y-%m-%d %H:%M:%S")
        .map_err(|e| format!("结束时间格式错误: {}", e))?;

    let limit = limit.unwrap_or(50);

    let result = state
        .dashboard_api
        .list_action_logs_by_material(&material_id, start, end, limit)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询操作日志（按版本）
#[tauri::command(rename_all = "snake_case")]
pub async fn list_action_logs_by_version(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .dashboard_api
        .list_action_logs_by_version(&version_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询最近操作
#[tauri::command(rename_all = "snake_case")]
pub async fn get_recent_actions(
    state: tauri::State<'_, AppState>,
    limit: i32,
    offset: Option<i32>,
    start_time: Option<String>,
    end_time: Option<String>,
) -> Result<String, String> {
    use chrono::NaiveDateTime;

    let offset = offset.unwrap_or(0);

    let start = start_time
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(|s| {
            NaiveDateTime::parse_from_str(s, "%Y-%m-%d %H:%M:%S")
                .map_err(|e| format!("开始时间格式错误: {}", e))
        })
        .transpose()?;

    let end = end_time
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(|s| {
            NaiveDateTime::parse_from_str(s, "%Y-%m-%d %H:%M:%S")
                .map_err(|e| format!("结束时间格式错误: {}", e))
        })
        .transpose()?;

    let result = if offset != 0 || start.is_some() || end.is_some() {
        state
            .dashboard_api
            .get_recent_actions_filtered(limit, offset, start, end)
            .map_err(map_api_error)?
    } else {
        state
            .dashboard_api
            .get_recent_actions(limit)
            .map_err(map_api_error)?
    };

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 配置管理相关命令
// ==========================================

/// 查询所有配置
#[tauri::command(rename_all = "snake_case")]
pub async fn list_configs(state: tauri::State<'_, AppState>) -> Result<String, String> {
    let result = state.config_api.list_configs().map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询单个配置
#[tauri::command(rename_all = "snake_case")]
pub async fn get_config(
    state: tauri::State<'_, AppState>,
    scope_id: String,
    key: String,
) -> Result<String, String> {
    let result = state
        .config_api
        .get_config(&scope_id, &key)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 更新配置
#[tauri::command(rename_all = "snake_case")]
pub async fn update_config(
    state: tauri::State<'_, AppState>,
    scope_id: String,
    key: String,
    value: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    state
        .config_api
        .update_config(&scope_id, &key, &value, &operator, &reason)
        .map_err(map_api_error)?;

    Ok("{}".to_string())
}

/// 批量更新配置
#[tauri::command(rename_all = "snake_case")]
pub async fn batch_update_configs(
    state: tauri::State<'_, AppState>,
    configs: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    use crate::api::config_api::ConfigItem;

    let configs: Vec<ConfigItem> =
        serde_json::from_str(&configs).map_err(|e| format!("解析配置列表失败: {}", e))?;

    let count = state
        .config_api
        .batch_update_configs(configs, &operator, &reason)
        .map_err(map_api_error)?;

    serde_json::to_string(&serde_json::json!({ "updated_count": count }))
        .map_err(|e| format!("序列化失败: {}", e))
}

/// 获取配置快照
#[tauri::command(rename_all = "snake_case")]
pub async fn get_config_snapshot(state: tauri::State<'_, AppState>) -> Result<String, String> {
    state
        .config_api
        .get_config_snapshot()
        .map_err(map_api_error)
}

/// 从快照恢复配置
#[tauri::command(rename_all = "snake_case")]
pub async fn restore_config_from_snapshot(
    state: tauri::State<'_, AppState>,
    snapshot_json: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    let count = state
        .config_api
        .restore_from_snapshot(&snapshot_json, &operator, &reason)
        .map_err(map_api_error)?;

    serde_json::to_string(&serde_json::json!({ "restored_count": count }))
        .map_err(|e| format!("序列化失败: {}", e))
}

/// 保存自定义策略（持久化到 config_kv）
#[tauri::command(rename_all = "snake_case")]
pub async fn save_custom_strategy(
    state: tauri::State<'_, AppState>,
    strategy_json: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    use crate::config::strategy_profile::CustomStrategyProfile;

    let profile: CustomStrategyProfile =
        serde_json::from_str(&strategy_json).map_err(|e| format!("解析自定义策略失败: {}", e))?;

    let resp = state
        .config_api
        .save_custom_strategy(profile, &operator, &reason)
        .map_err(map_api_error)?;

    serde_json::to_string(&resp).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询所有自定义策略
#[tauri::command(rename_all = "snake_case")]
pub async fn list_custom_strategies(
    state: tauri::State<'_, AppState>,
) -> Result<String, String> {
    let result = state
        .config_api
        .list_custom_strategies()
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 换辊管理相关命令
// ==========================================

/// 查询版本的所有换辊窗口
#[tauri::command(rename_all = "snake_case")]
pub async fn list_roll_campaigns(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .roller_api
        .list_campaigns(&version_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询机组当前进行中的换辊窗口
#[tauri::command(rename_all = "snake_case")]
pub async fn get_active_roll_campaign(
    state: tauri::State<'_, AppState>,
    version_id: String,
    machine_code: String,
) -> Result<String, String> {
    let result = state
        .roller_api
        .get_active_campaign(&version_id, &machine_code)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 查询需要换辊的机组列表
#[tauri::command(rename_all = "snake_case")]
pub async fn list_needs_roll_change(
    state: tauri::State<'_, AppState>,
    version_id: String,
) -> Result<String, String> {
    let result = state
        .roller_api
        .list_needs_roll_change(&version_id)
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 创建新的换辊窗口
#[tauri::command(rename_all = "snake_case")]
pub async fn create_roll_campaign(
    state: tauri::State<'_, AppState>,
    version_id: String,
    machine_code: String,
    campaign_no: i32,
    start_date: String,
    suggest_threshold_t: Option<f64>,
    hard_limit_t: Option<f64>,
    operator: String,
    reason: String,
) -> Result<String, String> {
    let start_date = parse_date(&start_date)?;

    state
        .roller_api
        .create_campaign(
            &version_id,
            &machine_code,
            campaign_no,
            start_date,
            suggest_threshold_t,
            hard_limit_t,
            &operator,
            &reason,
        )
        .map_err(map_api_error)?;

    Ok("{}".to_string())
}

/// 结束换辊窗口
#[tauri::command(rename_all = "snake_case")]
pub async fn close_roll_campaign(
    state: tauri::State<'_, AppState>,
    version_id: String,
    machine_code: String,
    campaign_no: i32,
    end_date: String,
    operator: String,
    reason: String,
) -> Result<String, String> {
    let end_date = parse_date(&end_date)?;

    state
        .roller_api
        .close_campaign(
            &version_id,
            &machine_code,
            campaign_no,
            end_date,
            &operator,
            &reason,
        )
        .map_err(map_api_error)?;

    Ok("{}".to_string())
}

// ==========================================
// 决策支持相关命令
// ==========================================

/// D1: 查询日期风险摘要 - "哪天最危险"
///
/// # 参数
/// - version_id: 方案版本ID
/// - date_from: 日期范围起始 (YYYY-MM-DD)
/// - date_to: 日期范围结束 (YYYY-MM-DD)
/// - risk_level_filter: 风险等级过滤 (可选, JSON数组字符串, 如: ["HIGH", "CRITICAL"])
/// - limit: 返回条数限制 (可选, 默认10)
/// - sort_by: 排序方式 (可选, "risk_score" | "plan_date" | "capacity_util_pct")
///
/// # 返回
/// - 成功: JSON字符串, 包含日期风险摘要列表
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_decision_day_summary(
    state: tauri::State<'_, AppState>,
    version_id: String,
    date_from: String,
    date_to: String,
    risk_level_filter: Option<String>,
    limit: Option<u32>,
    sort_by: Option<String>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, GetDecisionDaySummaryRequest};

    // 解析风险等级过滤器
    let risk_level_filter = if let Some(filter_str) = risk_level_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("风险等级过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = GetDecisionDaySummaryRequest {
        version_id,
        date_from,
        date_to,
        risk_level_filter,
        limit,
        sort_by,
    };

    // 调用 DecisionApi
    let response = state.decision_api.get_decision_day_summary(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

/// D4: 查询机组堵塞概况 - "哪个机组最堵"
///
/// # 参数
/// - version_id: 方案版本ID
/// - date_from: 日期范围起始 (YYYY-MM-DD)
/// - date_to: 日期范围结束 (YYYY-MM-DD)
/// - machine_codes: 机组代码过滤 (可选, JSON数组字符串, 如: ["H032", "H033"])
/// - bottleneck_level_filter: 堵塞等级过滤 (可选, JSON数组字符串, 如: ["HIGH", "CRITICAL"])
/// - bottleneck_type_filter: 堵塞类型过滤 (可选, JSON数组字符串, 如: ["Capacity", "Structure"])
/// - limit: 返回条数限制 (可选, 默认50)
///
/// # 返回
/// - 成功: JSON字符串, 包含机组堵塞点列表和热力图统计
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_machine_bottleneck_profile(
    state: tauri::State<'_, AppState>,
    version_id: String,
    date_from: String,
    date_to: String,
    machine_codes: Option<String>,
    bottleneck_level_filter: Option<String>,
    bottleneck_type_filter: Option<String>,
    limit: Option<u32>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, GetMachineBottleneckProfileRequest};

    // 解析机组代码过滤器
    let machine_codes = if let Some(codes_str) = machine_codes {
        let parsed: Vec<String> = serde_json::from_str(&codes_str)
            .map_err(|e| format!("机组代码过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析堵塞等级过滤器
    let bottleneck_level_filter = if let Some(filter_str) = bottleneck_level_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("堵塞等级过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析堵塞类型过滤器
    let bottleneck_type_filter = if let Some(filter_str) = bottleneck_type_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("堵塞类型过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = GetMachineBottleneckProfileRequest {
        version_id,
        date_from,
        date_to,
        machine_codes,
        bottleneck_level_filter,
        bottleneck_type_filter,
        limit,
    };

    // 调用 DecisionApi
    let response = state.decision_api.get_machine_bottleneck_profile(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

/// D2: 查询紧急订单失败集合 - "哪些紧急单无法完成"
///
/// # 参数
/// - version_id: 方案版本ID
/// - fail_type_filter: 失败类型过滤 (可选, JSON数组字符串, 如: ["Overdue", "CapacityShortage"])
/// - urgency_level_filter: 紧急等级过滤 (可选, JSON数组字符串, 如: ["L2", "L3"])
/// - machine_codes: 机组代码过滤 (可选, JSON数组字符串, 如: ["H032", "H033"])
/// - due_date_from: 交货日期范围起始 (可选, YYYY-MM-DD)
/// - due_date_to: 交货日期范围结束 (可选, YYYY-MM-DD)
/// - completion_rate_threshold: 完成率阈值 (可选, 0-100)
/// - limit: 返回条数限制 (可选, 默认50)
/// - offset: 分页偏移 (可选, 默认0)
///
/// # 返回
/// - 成功: JSON字符串, 包含订单失败列表和统计摘要
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn list_order_failure_set(
    state: tauri::State<'_, AppState>,
    version_id: String,
    fail_type_filter: Option<String>,
    urgency_level_filter: Option<String>,
    machine_codes: Option<String>,
    due_date_from: Option<String>,
    due_date_to: Option<String>,
    completion_rate_threshold: Option<f64>,
    limit: Option<u32>,
    offset: Option<u32>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, ListOrderFailureSetRequest};

    // 解析失败类型过滤器
    let fail_type_filter = if let Some(filter_str) = fail_type_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("失败类型过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析紧急等级过滤器
    let urgency_level_filter = if let Some(filter_str) = urgency_level_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("紧急等级过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析机组代码过滤器
    let machine_codes = if let Some(codes_str) = machine_codes {
        let parsed: Vec<String> = serde_json::from_str(&codes_str)
            .map_err(|e| format!("机组代码过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = ListOrderFailureSetRequest {
        version_id,
        fail_type_filter,
        urgency_level_filter,
        machine_codes,
        due_date_from,
        due_date_to,
        completion_rate_threshold,
        limit,
        offset,
    };

    // 调用 DecisionApi
    let response = state.decision_api.list_order_failure_set(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

/// D3: 查询冷料压库概况 - "哪些冷料压库"
///
/// # 参数
/// - version_id: 方案版本ID
/// - machine_codes: 机组代码过滤 (可选, JSON数组字符串, 如: ["H032", "H033"])
/// - pressure_level_filter: 压库等级过滤 (可选, JSON数组字符串, 如: ["HIGH", "CRITICAL"])
/// - age_bin_filter: 库龄分组过滤 (可选, JSON数组字符串, 如: ["30-60", "60-90", "90+"])
/// - limit: 返回条数限制 (可选, 默认50)
///
/// # 返回
/// - 成功: JSON字符串, 包含冷料压库概况列表和统计摘要
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_cold_stock_profile(
    state: tauri::State<'_, AppState>,
    version_id: String,
    machine_codes: Option<String>,
    pressure_level_filter: Option<String>,
    age_bin_filter: Option<String>,
    limit: Option<u32>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, GetColdStockProfileRequest};

    // 解析机组代码过滤器
    let machine_codes = if let Some(codes_str) = machine_codes {
        let parsed: Vec<String> = serde_json::from_str(&codes_str)
            .map_err(|e| format!("机组代码过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析压库等级过滤器
    let pressure_level_filter = if let Some(filter_str) = pressure_level_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("压库等级过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析库龄分组过滤器
    let age_bin_filter = if let Some(filter_str) = age_bin_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("库龄分组过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = GetColdStockProfileRequest {
        version_id,
        machine_codes,
        pressure_level_filter,
        age_bin_filter,
        limit,
    };

    // 调用 DecisionApi
    let response = state.decision_api.get_cold_stock_profile(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

/// D5: 查询轧制活动警报 - "换辊是否异常"
///
/// # 参数
/// - version_id: 方案版本ID
/// - machine_codes: 机组代码过滤 (可选, JSON数组字符串, 如: ["H032", "H033"])
/// - alert_level_filter: 警报等级过滤 (可选, JSON数组字符串, 如: ["WARNING", "CRITICAL"])
/// - alert_type_filter: 警报类型过滤 (可选, JSON数组字符串)
/// - date_from: 日期范围起始 (可选, YYYY-MM-DD)
/// - date_to: 日期范围结束 (可选, YYYY-MM-DD)
/// - limit: 返回条数限制 (可选)
///
/// # 返回
/// - 成功: JSON字符串, 包含换辊警报列表和统计摘要
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_roll_campaign_alert(
    state: tauri::State<'_, AppState>,
    version_id: String,
    machine_codes: Option<String>,
    alert_level_filter: Option<String>,
    alert_type_filter: Option<String>,
    date_from: Option<String>,
    date_to: Option<String>,
    limit: Option<u32>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, ListRollCampaignAlertsRequest};

    // 解析机组代码过滤器
    let machine_codes = if let Some(codes_str) = machine_codes {
        let parsed: Vec<String> = serde_json::from_str(&codes_str)
            .map_err(|e| format!("机组代码过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析警报等级过滤器
    let alert_level_filter = if let Some(filter_str) = alert_level_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("警报等级过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析警报类型过滤器
    let alert_type_filter = if let Some(filter_str) = alert_type_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("警报类型过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = ListRollCampaignAlertsRequest {
        version_id,
        machine_codes,
        alert_level_filter,
        alert_type_filter,
        date_from,
        date_to,
        limit,
    };

    // 调用 DecisionApi
    let response = state.decision_api.list_roll_campaign_alerts(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

/// D6: 查询容量优化机会 - "是否存在产能优化空间"
///
/// # 参数
/// - version_id: 方案版本ID
/// - date_from: 日期范围起始 (可选, YYYY-MM-DD)
/// - date_to: 日期范围结束 (可选, YYYY-MM-DD)
/// - machine_codes: 机组代码过滤 (可选, JSON数组字符串, 如: ["H032", "H033"])
/// - opportunity_type_filter: 机会类型过滤 (可选, JSON数组字符串)
/// - min_opportunity_t: 最小机会吨位阈值 (可选, 默认10.0)
/// - limit: 返回条数限制 (可选)
///
/// # 返回
/// - 成功: JSON字符串, 包含容量优化机会列表和统计摘要
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_capacity_opportunity(
    state: tauri::State<'_, AppState>,
    version_id: String,
    date_from: Option<String>,
    date_to: Option<String>,
    machine_codes: Option<String>,
    opportunity_type_filter: Option<String>,
    min_opportunity_t: Option<f64>,
    limit: Option<u32>,
) -> Result<String, String> {
    use crate::decision::api::{DecisionApi, GetCapacityOpportunityRequest};

    // 解析机组代码过滤器
    let machine_codes = if let Some(codes_str) = machine_codes {
        let parsed: Vec<String> = serde_json::from_str(&codes_str)
            .map_err(|e| format!("机组代码过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 解析机会类型过滤器
    let opportunity_type_filter = if let Some(filter_str) = opportunity_type_filter {
        let parsed: Vec<String> = serde_json::from_str(&filter_str)
            .map_err(|e| format!("机会类型过滤器格式错误: {}", e))?;
        Some(parsed)
    } else {
        None
    };

    // 构建请求
    let request = GetCapacityOpportunityRequest {
        version_id,
        machine_codes,
        date_from,
        date_to,
        opportunity_type_filter,
        min_opportunity_t,
        limit,
    };

    // 调用 DecisionApi
    let response = state.decision_api.get_capacity_opportunity(request)?;

    // 序列化返回
    serde_json::to_string(&response).map_err(|e| format!("序列化失败: {}", e))
}

// ==========================================
// 材料导入相关命令
// ==========================================

/// 导入材料数据
#[tauri::command(rename_all = "snake_case")]
pub async fn import_materials(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    file_path: String,
    source_batch_id: String,
    mapping_profile_id: Option<String>,
) -> Result<String, String> {
    // 调试日志
    tracing::info!("[import_materials] 收到请求:");
    tracing::info!("  file_path: {}", file_path);
    tracing::info!("  source_batch_id: {}", source_batch_id);
    tracing::info!("  mapping_profile_id: {:?}", mapping_profile_id);

    let result = state
        .import_api
        .import_materials(
            &file_path,
            &source_batch_id,
            mapping_profile_id.as_deref(),
        )
        .await
        .map_err(|e| {
            tracing::error!("[import_materials] 导入失败: {:?}", e);
            map_api_error(e)
        })?;

    tracing::info!("[import_materials] 导入成功: {:?}", result);
    emit_frontend_event(
        &app,
        "material_state_changed",
        serde_json::json!({ "source_batch_id": source_batch_id }),
    );
    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 列出导入冲突
#[tauri::command(rename_all = "snake_case")]
pub async fn list_import_conflicts(
    state: tauri::State<'_, AppState>,
    status: Option<String>,
    limit: i32,
    offset: i32,
    batch_id: Option<String>,
) -> Result<String, String> {
    let result = state
        .import_api
        .list_import_conflicts(status.as_deref(), limit, offset, batch_id.as_deref())
        .await
        .map_err(map_api_error)?;

    serde_json::to_string(&result).map_err(|e| format!("序列化失败: {}", e))
}

/// 解决导入冲突
///
/// # 参数
/// - conflict_id: 冲突记录ID
/// - action: 解决动作 (KEEP_EXISTING/OVERWRITE/MERGE)
/// - note: 解决备注 (可选)
/// - operator: 操作人 (可选，默认 "system")
///
/// # 返回
/// - 成功: 空JSON对象
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn resolve_import_conflict(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    conflict_id: String,
    action: String,
    note: Option<String>,
    operator: Option<String>,
) -> Result<String, String> {
    use crate::domain::action_log::ActionLog;

    let operator = operator.unwrap_or_else(|| "system".to_string());

    // 解决冲突并获取冲突详情
    let conflict = state
        .import_api
        .resolve_import_conflict(&conflict_id, &action, note.as_deref())
        .await
        .map_err(map_api_error)?;

    // 记录 ActionLog（红线5：可解释性/审计追踪）
    let action_log = ActionLog {
        action_id: uuid::Uuid::new_v4().to_string(),
        version_id: "N/A".to_string(),
        action_type: "RESOLVE_IMPORT_CONFLICT".to_string(),
        action_ts: chrono::Local::now().naive_local(),
        actor: operator,
        payload_json: Some(serde_json::json!({
            "conflict_id": conflict_id,
            "action": action,
            "note": note,
        })),
        impact_summary_json: Some(serde_json::json!({
            "material_id": conflict.material_id,
            "conflict_type": format!("{:?}", conflict.conflict_type),
            "batch_id": conflict.batch_id,
            "resolution_action": action,
        })),
        machine_code: None,
        date_range_start: None,
        date_range_end: None,
        detail: note,
    };

    // 尝试记录 ActionLog，失败时只记录警告
    if let Err(e) = state.action_log_repo.insert(&action_log) {
        tracing::warn!(error = %e, "记录冲突解决操作日志失败");
    }

    emit_frontend_event(&app, "material_state_changed", serde_json::json!({}));

    Ok("{}".to_string())
}

// ==========================================
// 产能池管理相关命令
// ==========================================

/// 查询产能池列表
///
/// # 参数
/// - machine_codes: 机组代码列表 (JSON数组字符串, 如: ["H032", "H033"])
/// - date_from: 日期范围起始 (YYYY-MM-DD)
/// - date_to: 日期范围结束 (YYYY-MM-DD)
/// - version_id: 方案版本ID (可选，暂未使用)
///
/// # 返回
/// - 成功: JSON字符串, 包含产能池列表
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn get_capacity_pools(
    state: tauri::State<'_, AppState>,
    machine_codes: String,
    date_from: String,
    date_to: String,
    _version_id: Option<String>,
) -> Result<String, String> {
    use chrono::NaiveDate;

    // 解析机组代码列表
    let codes: Vec<String> = serde_json::from_str(&machine_codes)
        .map_err(|e| format!("机组代码格式错误: {}", e))?;

    // 解析日期
    let start_date = NaiveDate::parse_from_str(&date_from, "%Y-%m-%d")
        .map_err(|e| format!("起始日期格式错误（应为YYYY-MM-DD）: {}", e))?;
    let end_date = NaiveDate::parse_from_str(&date_to, "%Y-%m-%d")
        .map_err(|e| format!("结束日期格式错误（应为YYYY-MM-DD）: {}", e))?;

    // 收集所有机组的产能池
    let mut all_pools = Vec::new();

    for code in &codes {
        let pools = state
            .capacity_pool_repo
            .find_by_date_range(code, start_date, end_date)
            .map_err(|e| format!("查询产能池失败: {}", e))?;
        all_pools.extend(pools);
    }

    // 序列化返回
    serde_json::to_string(&all_pools).map_err(|e| format!("序列化失败: {}", e))
}

/// 更新产能池参数
///
/// # 参数
/// - machine_code: 机组代码
/// - plan_date: 计划日期 (YYYY-MM-DD)
/// - target_capacity_t: 目标产能（吨）
/// - limit_capacity_t: 上限产能（吨）
/// - reason: 修改原因
///
/// # 返回
/// - 成功: 空JSON对象
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn update_capacity_pool(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    machine_code: String,
    plan_date: String,
    target_capacity_t: f64,
    limit_capacity_t: f64,
    reason: String,
    operator: String,
    version_id: Option<String>,
) -> Result<String, String> {
    use chrono::NaiveDate;
    use crate::domain::capacity::CapacityPool;
    use crate::domain::action_log::ActionLog;

    // 解析日期
    let date = NaiveDate::parse_from_str(&plan_date, "%Y-%m-%d")
        .map_err(|e| format!("日期格式错误（应为YYYY-MM-DD）: {}", e))?;

    // 验证参数
    if target_capacity_t < 0.0 {
        return Err("目标产能不能为负数".to_string());
    }
    if limit_capacity_t < 0.0 {
        return Err("上限产能不能为负数".to_string());
    }
    if limit_capacity_t < target_capacity_t {
        return Err("上限产能不能小于目标产能".to_string());
    }

    tracing::info!(
        "[update_capacity_pool] 更新产能池: {} {} target={} limit={} reason={} operator={}",
        machine_code, plan_date, target_capacity_t, limit_capacity_t, reason, operator
    );

    // 查询现有产能池
    let existing = state
        .capacity_pool_repo
        .find_by_machine_and_date(&machine_code, date)
        .map_err(|e| format!("查询产能池失败: {}", e))?;

    // 记录旧值用于审计
    let old_target = existing.as_ref().map(|p| p.target_capacity_t);
    let old_limit = existing.as_ref().map(|p| p.limit_capacity_t);

    // 构造新的产能池数据
    let pool = match existing {
        Some(mut p) => {
            // 更新现有记录
            p.target_capacity_t = target_capacity_t;
            p.limit_capacity_t = limit_capacity_t;
            p
        }
        None => {
            // 创建新记录
            CapacityPool {
                machine_code: machine_code.clone(),
                plan_date: date,
                target_capacity_t,
                limit_capacity_t,
                used_capacity_t: 0.0,
                overflow_t: 0.0,
                frozen_capacity_t: 0.0,
                accumulated_tonnage_t: 0.0,
                roll_campaign_id: None,
            }
        }
    };

    // 保存到数据库
    state
        .capacity_pool_repo
        .upsert_single(&pool)
        .map_err(|e| format!("更新产能池失败: {}", e))?;

    let version_id_for_log = version_id
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .unwrap_or("N/A")
        .to_string();

    // 记录 ActionLog（红线5：可解释性/审计追踪）
    let action_log = ActionLog {
        action_id: uuid::Uuid::new_v4().to_string(),
        version_id: version_id_for_log,
        action_type: "UPDATE_CAPACITY_POOL".to_string(),
        action_ts: chrono::Local::now().naive_local(),
        actor: operator.clone(),
        payload_json: Some(serde_json::json!({
            "machine_code": machine_code,
            "plan_date": plan_date,
            "target_capacity_t": target_capacity_t,
            "limit_capacity_t": limit_capacity_t,
            "reason": reason,
        })),
        impact_summary_json: Some(serde_json::json!({
            "old_target": old_target,
            "new_target": target_capacity_t,
            "old_limit": old_limit,
            "new_limit": limit_capacity_t,
        })),
        machine_code: Some(machine_code.clone()),
        date_range_start: Some(date),
        date_range_end: Some(date),
        detail: Some(reason),
    };

    // 尝试记录ActionLog，失败时只记录警告（不影响主要操作）
    if let Err(e) = state.action_log_repo.insert(&action_log) {
        tracing::warn!(error = %e, "记录产能池更新操作日志失败");
    }

    // 可选：触发决策读模型刷新（产能池参数修改可能影响超限/瓶颈等口径）
    if let Some(version_id) = version_id.as_deref().map(str::trim).filter(|s| !s.is_empty()) {
        if let Err(e) = state.plan_api.manual_refresh_decision(version_id, &operator) {
            tracing::warn!("产能池更新后触发决策刷新失败: {}", e);
        }

        emit_frontend_event(
            &app,
            "risk_snapshot_updated",
            serde_json::json!({ "version_id": version_id, "source": "update_capacity_pool" }),
        );
    }

    Ok("{}".to_string())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CapacityPoolUpdate {
    pub machine_code: String,
    pub plan_date: String,
    pub target_capacity_t: f64,
    pub limit_capacity_t: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchUpdateCapacityPoolsResponse {
    pub requested: usize,
    pub updated: usize,
    pub skipped: usize,
    pub upserted_rows: usize,
    pub refresh: Option<crate::api::plan_api::ManualRefreshDecisionResponse>,
    pub message: String,
}

/// 批量更新产能池参数（P2-1）
///
/// # 参数
/// - updates: JSON数组字符串，元素结构同 CapacityPoolUpdate
/// - reason: 修改原因（必填）
/// - operator: 操作人
/// - version_id: 关联版本（可选；若传入则会 best-effort 触发决策刷新）
///
/// # 返回
/// - 成功: JSON字符串, BatchUpdateCapacityPoolsResponse
/// - 失败: 错误消息
#[tauri::command(rename_all = "snake_case")]
pub async fn batch_update_capacity_pools(
    app: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
    updates: String,
    reason: String,
    operator: String,
    version_id: Option<String>,
) -> Result<String, String> {
    use chrono::NaiveDate;
    use crate::domain::capacity::CapacityPool;
    use crate::domain::action_log::ActionLog;

    if reason.trim().is_empty() {
        return Err("请输入调整原因".to_string());
    }
    if operator.trim().is_empty() {
        return Err("操作人不能为空".to_string());
    }

    let items: Vec<CapacityPoolUpdate> =
        serde_json::from_str(&updates).map_err(|e| format!("updates格式错误: {}", e))?;
    if items.is_empty() {
        return Err("updates不能为空".to_string());
    }

    let mut pools_to_upsert: Vec<CapacityPool> = Vec::new();
    let mut skipped = 0usize;

    let mut min_date: Option<NaiveDate> = None;
    let mut max_date: Option<NaiveDate> = None;

    // 为了避免 ActionLog payload 过大，对明细做截断（只保留 sample）
    let mut change_samples: Vec<serde_json::Value> = Vec::new();
    let max_samples: usize = 200;

    for it in &items {
        let date = NaiveDate::parse_from_str(&it.plan_date, "%Y-%m-%d")
            .map_err(|e| format!("日期格式错误（应为YYYY-MM-DD）: {}", e))?;

        // 验证参数
        if it.target_capacity_t < 0.0 {
            return Err(format!(
                "目标产能不能为负数: {} {}",
                it.machine_code, it.plan_date
            ));
        }
        if it.limit_capacity_t < 0.0 {
            return Err(format!(
                "上限产能不能为负数: {} {}",
                it.machine_code, it.plan_date
            ));
        }
        if it.limit_capacity_t < it.target_capacity_t {
            return Err(format!(
                "上限产能不能小于目标产能: {} {}",
                it.machine_code, it.plan_date
            ));
        }

        let existing = state
            .capacity_pool_repo
            .find_by_machine_and_date(&it.machine_code, date)
            .map_err(|e| format!("查询产能池失败: {}", e))?;

        // 跳过无变化项（避免无意义的 OR REPLACE + 审计噪音）
        let unchanged = existing.as_ref().is_some_and(|p| {
            (p.target_capacity_t - it.target_capacity_t).abs() < f64::EPSILON
                && (p.limit_capacity_t - it.limit_capacity_t).abs() < f64::EPSILON
        });
        if unchanged {
            skipped += 1;
            continue;
        }

        let old_target = existing.as_ref().map(|p| p.target_capacity_t);
        let old_limit = existing.as_ref().map(|p| p.limit_capacity_t);

        let pool = match existing {
            Some(mut p) => {
                p.target_capacity_t = it.target_capacity_t;
                p.limit_capacity_t = it.limit_capacity_t;
                p
            }
            None => CapacityPool {
                machine_code: it.machine_code.clone(),
                plan_date: date,
                target_capacity_t: it.target_capacity_t,
                limit_capacity_t: it.limit_capacity_t,
                used_capacity_t: 0.0,
                overflow_t: 0.0,
                frozen_capacity_t: 0.0,
                accumulated_tonnage_t: 0.0,
                roll_campaign_id: None,
            },
        };

        pools_to_upsert.push(pool);

        if change_samples.len() < max_samples {
            change_samples.push(serde_json::json!({
                "machine_code": it.machine_code,
                "plan_date": it.plan_date,
                "old_target": old_target,
                "new_target": it.target_capacity_t,
                "old_limit": old_limit,
                "new_limit": it.limit_capacity_t,
            }));
        }

        min_date = Some(min_date.map(|d| d.min(date)).unwrap_or(date));
        max_date = Some(max_date.map(|d| d.max(date)).unwrap_or(date));
    }

    let updated = pools_to_upsert.len();
    let requested = items.len();

    let upserted_rows = if pools_to_upsert.is_empty() {
        0
    } else {
        state
            .capacity_pool_repo
            .upsert_batch(pools_to_upsert)
            .map_err(|e| format!("批量更新产能池失败: {}", e))?
    };

    let version_id_for_log = version_id
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .unwrap_or("N/A")
        .to_string();

    let action_log = ActionLog {
        action_id: uuid::Uuid::new_v4().to_string(),
        version_id: version_id_for_log,
        action_type: "BATCH_UPDATE_CAPACITY_POOL".to_string(),
        action_ts: chrono::Local::now().naive_local(),
        actor: operator.clone(),
        payload_json: Some(serde_json::json!({
            "requested": requested,
            "updated": updated,
            "skipped": skipped,
            "reason": reason,
            "changes_sample": change_samples,
            "sample_truncated": requested.saturating_sub(skipped) > max_samples,
        })),
        impact_summary_json: Some(serde_json::json!({
            "requested": requested,
            "updated": updated,
            "skipped": skipped,
            "upserted_rows": upserted_rows,
        })),
        machine_code: None,
        date_range_start: min_date,
        date_range_end: max_date,
        detail: Some("批量更新产能池参数".to_string()),
    };

    if let Err(e) = state.action_log_repo.insert(&action_log) {
        tracing::warn!(error = %e, "记录批量产能池更新操作日志失败");
    }

    // best-effort：若提供 version_id，则触发决策刷新，并 emit 一个事件让前端及时拉取刷新状态。
    let refresh = if updated == 0 {
        None
    } else if let Some(vid) = version_id.as_deref().map(str::trim).filter(|s| !s.is_empty()) {
        let resp = match state.plan_api.manual_refresh_decision(vid, &operator) {
            Ok(r) => r,
            Err(e) => {
                tracing::warn!("批量更新产能池后触发决策刷新失败: {}", e);
                crate::api::plan_api::ManualRefreshDecisionResponse {
                    version_id: vid.to_string(),
                    task_id: None,
                    success: false,
                    message: format!("触发决策刷新失败: {}", e),
                }
            }
        };

        emit_frontend_event(
            &app,
            "risk_snapshot_updated",
            serde_json::json!({ "version_id": vid, "source": "batch_update_capacity_pools" }),
        );

        Some(resp)
    } else {
        None
    };

    let resp = BatchUpdateCapacityPoolsResponse {
        requested,
        updated,
        skipped,
        upserted_rows,
        refresh,
        message: if updated == 0 {
            "无变更，已跳过".to_string()
        } else {
            "批量更新完成".to_string()
        },
    };

    serde_json::to_string(&resp).map_err(|e| format!("序列化失败: {}", e))
}
